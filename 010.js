/**
 *  盛最多水的容器
 * @param {*} height 
 */
var maxArea = function(height) {
    var max = 0
    var i = 0
    var j = height.length - 1
    var minHeight = 0
    while(true){
        if(i === j){
            break
        }else{
            var width = j - i
            minHeight = height[i] > height[j]?(height[j--]):(height[i++])
            if(minHeight*width > max){
                max = minHeight*width
            }
        }
    }
    return max
};
/**
 * 这道题目看似简单，做起来才发现不容易。分治法、动态规划都用不上，
 * 要想得到 O(n)O(n) 的解法只有使用双指针一条路。即使看了答案知道了双指针解法，
 * 你也可能并不清楚这个解法为什么正确。为什么双指针往中间移动时，不会漏掉某些情况呢？
 * 如果没有真正理解题目，即使一次对着答案做出来了，再次遇到这个题目，还是可能做不出来。
 * 要理解这道题的正确性和原理，需要从背后的缩减搜索空间的思想去考虑题解。
 * 所谓的缩减收缩空间是这样的。如果我们暴力的去破解的话，我们需要把每一种情况都要给遍历出来，
 * 然后找到水的最大容量，那么此时问题就来了，有一些很明显的搜索其实我们不用去做，什么意思呢？我们来举一个例子
 * 
 * 假如我们接收的数组是[2,3,2,1,4]，如果按照暴力搜索的方式，我们以第一个元素2为起点，分别搜索(2,3)(2,2)(2,1)(2,4)
 * 其实我很负责的告诉你，你只需要计算(2,4)的水容量，其他的一定没有(2,4)的大，所以其实这些没有必要去计算。因为它们的高度
 * 已经被限制为2，并且宽度逐渐增大的，所以处理最后一组可以值得计算，其他的都不需要计算。
 * 
 * 为什么双指针(这里采用碰撞指针)可以奏效，是因为双指针减少了我们需要遍历的元素，也就是减少了搜索空间。我们来举一个例子
 * 假如我们要遍历上面的数组，那么我们的搜索空间为Cn2 = 10，现在我们以第一个和第五个元素为例，那么我们只需要计算(2,4)
 * 此时我们只计算了一次，那么其他的因为一定比这个值小我们直接跳过，那么我们直接跳过，此时搜索空间减去3。现在的搜索空间
 * 为7，减去已经计算的(2,4)现在为6。然后第二个元素和第五个元素。这里解释一下为什值比较小的那个指针向前移，因为如果后面
 * 的指针移动还是在2的范围内，水的体积只会越小，而不会越大，而小的值向前移那么水的体积可能会变大。大的向前移一定会变小
 * 当我们计算第二个元素和第五个元素的时候，那么(3,2)(3,1)就不用计算，此时搜索空间又少了两个，加上(3,4)，此时搜索空间
 * 还剩6 - 3 = 3。然后就是(2,4)，同样的道理，去掉(2,1)，此时空间还有3 - 2 = 1。也就是只剩下(1,4)了。
 * 这就是双指针对缩减空间的利用。双指针可以使我们的时间复杂度降为O(n)。空间复杂度为O(1)。
 */